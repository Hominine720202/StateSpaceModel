---
title: "MQC_IQC_kalman"
author: "Ryuho"
date: "6/25/2019"
output: html_document
---
```{r}
library(tidyverse); library(gridExtra); library(KFAS)
set.seed(7)

# 共通の状態成分（ランダムウォーク）
n_sample <- 200
a_sd <- 0.1
a0 <- 5
state <- a0 + cumsum(rnorm(n_sample, mean=0, sd=a_sd))

# IQc, MQCへの変換の係数
w_iqc <- 2.0
w_mqc <- 3.0

# 説明変数
exog <- matrix(c(rep(1, 50), rep(5, 100), rep(2, 50)))

# 回帰係数
beta_iqc <- 1.5
beta_mqc <- 2.0

# 観測値
obs_sd <- 0.8
mqc_error <- rnorm(n = n_sample, sd = obs_sd)
iqc_error <- rnorm(n = n_sample, sd = obs_sd)

y_iqc <- w_iqc * state + beta_iqc * exog + iqc_error
y_mqc <- w_mqc * state + beta_mqc * exog + mqc_error


# 観測値がIQCかMQCか？ 
mqc_inerval <- 5 
is_mqc <- numeric(n_sample)
is_mqc[seq(1, n_sample, mqc_inerval)] <- 1


comp_data <- data.frame(t=1:n_sample, 
                       state=state, 
                       iqc_comp=y_iqc, 
                       mqc_comp=y_mqc, 
                       is_mqc=is_mqc, 
                       x=exog)

obs_data <- comp_data %>% 
  mutate(iqc=ifelse(is_mqc, NA, iqc_comp)) %>% 
  mutate(mqc=ifelse(is_mqc, mqc_comp, NA)) %>% 
  mutate(y=ifelse(is_mqc, mqc_comp, iqc_comp))

p1 <- ggplot(data=obs_data, aes(x=t, y=iqc)) + 
  geom_point(size=1) +
  geom_point(aes(y=mqc), color='red') 
  # ggsave('mqc_iqc_sim_data.png', width=8, height=4)

p2 <- ggplot(data=obs_data, aes(x=t, y=state)) + 
  geom_line() 

p3 <- ggplot(data=obs_data, aes(x=t, y=x)) + 
  geom_step() # ggsave('mqc_iqc_sim_data.png', width=8, height=4)

# g <- arrangeGrob(p1, p2, nrow=2) #generates g
# ggsave('mqc_iqc_sim_data.png', g) #saves g
grid.arrange(p1, p2, p3)
```


```{r}
# system matrixを再利用するため、単純な回帰成分モデルを作成
base_mod <- SSModel(data = obs_data,
               cbind(iqc, mqc) ~ 
                 SSMtrend(1, Q = NA, type = 'common') +
                 x,
               H = diag(NA,2))
fit_base <- fitSSM(base_mod, inits=numeric(3))
kfs_base <- KFS(fit_base$model)

Z <- base_mod$Z
# 水準成分に対する係数を推定対象とする
Z[,'level',] <- NA

mod_custom <- SSModel(data = obs_data,
               cbind(iqc, mqc) ~ -1 +
                 SSMcustom(Z = Z, T = base_mod$T, R = base_mod$R, Q = NA,
                           state_names = c('exog.iqc', 'exog.mqc', 'level'),
                           a1 = c(1.5, 2.5, 0)),
               H = diag(NA, 2))

update_model <- function(pars, model) {
  # H, Q, Zを更新する
  model$Q <- array(exp(pars[1]), rep(1, 3))
  model$H <- array(diag(exp(pars[2:3]), 2), c(2, 2, 1))
  model$Z[,'level',] <- pars[4:5] 
  model$a1[1:2] <- pars[6:7] 
  model
}

fit <- fitSSM(mod_custom, inits = numeric(7), updatefn = update_model)
# fit <- fitSSM(mod_custom, inits = c(1,2,3,4,5), updatefn = update_model)
kfs <- KFS(fit$model, filtering = c('state', 'signal'), smoothing = c('state', 'signal'))
```


```{r}
print(fit$model$H)
print(fit$model$Q)
print(fit$model$Z[,'level',1])
print(fit$model$a1)
```



```{r}
res <- data.frame(kfs$a[1:nrow(obs_data),], kfs$m, kfs$muhat)
colnames(res) <- c("beta_1", "beta_2", "level", 
                   "pred_iqc", "pred_mqc",
                   "smoothed_iqc", "smoothed_mqc")
res <- data.frame(cbind(obs_data, res))
```


```{r}
res %>% 
  # slice(48:52) %>% 
  ggplot(aes(x=t, y=iqc)) + 
  geom_point(size=1) +
  geom_point(aes(y=mqc), color='red') +
  geom_line(aes(y=pred_iqc), color='blue') +
  geom_line(aes(y=pred_mqc), color='magenta')
```


```{r}
res %>% 
  slice(49:53) %>% 
  ggplot(aes(x=t, y=iqc)) + 
  geom_point(size=1) +
  geom_point(aes(y=mqc), color='red') +
  geom_line(aes(y=pred_iqc), color='blue') +
  geom_line(aes(y=pred_mqc), color='magenta')

```

```{r}
res %>% 
  slice(143:156) %>% 
  ggplot(aes(x=t, y=iqc)) + 
  geom_point(size=1) +
  geom_point(aes(y=mqc), color='red') +
  geom_line(aes(y=pred_iqc), color='blue') +
  geom_line(aes(y=pred_mqc), color='magenta')

res %>%
  mutate(iqc_mqc_ratio = pred_mqc / pred_iqc) %>% 
  ggplot(aes(x=t, y=iqc_mqc_ratio)) +
  geom_point()
```

回帰係数を時変にする場合
```{r}
# system matrixを再利用するため、単純な回帰成分モデルを作成
base_mod <- SSModel(data = obs_data,
               cbind(iqc, mqc) ~ 
                 SSMtrend(1, Q = NA, type = 'common') +
                 SSMregression(~ x, type = 'distinct', index = 1, Q = NA) +
                 SSMregression(~ x, type = 'distinct', index = 2, Q = NA),
               H = diag(NA,2))

fit_base <- fitSSM(base_mod, inits=numeric(5))
kfs_base <- KFS(fit_base$model)

Z <- base_mod$Z
# 水準成分に対する係数を推定対象とする
Z[,'level',] <- NA

mod_custom <- SSModel(data = obs_data,
               cbind(iqc, mqc) ~ -1 +
                 SSMcustom(Z = Z, T = base_mod$T, R = base_mod$R, Q = base_mod$Q,
                           state_names = c('exog.iqc', 'exog.mqc', 'level')),
               H = diag(NA, 2))

update_model <- function(pars, model) {
  # H, Q, Zを更新する
  model$Q <- array(diag(exp(pars[1:3])), c(3, 3, 1))
  model$H <- array(diag(exp(pars[4:5]), 2), c(2, 2, 1))
  model
}

fit <- fitSSM(mod_custom, inits = numeric(5), updatefn = update_model)
# fit <- fitSSM(mod_custom, inits = c(1,2,3,4,5), updatefn = update_model)
kfs <- KFS(fit$model, filtering = c('state', 'signal'), smoothing = c('state', 'signal'))


res <- data.frame(kfs$a[1:nrow(obs_data),], kfs$m, kfs$muhat)
colnames(res) <- c("beta_1", "beta_2", "level", 
                   "pred_iqc", "pred_mqc",
                   "smoothed_iqc", "smoothed_mqc")
res <- data.frame(cbind(obs_data, res))


res %>% 
  # slice(48:52) %>% 
  ggplot(aes(x=t, y=iqc)) + 
  geom_point(size=1) +
  geom_point(aes(y=mqc), color='red') +
  geom_line(aes(y=pred_iqc), color='blue') +
  geom_line(aes(y=pred_mqc), color='magenta')
```



```
Z <- base_mod$Z
# 水準成分に対する係数を推定対象とする
Z[,'level',] <- NA

mod_custom <- SSModel(data = obs_data,
               cbind(iqc, mqc) ~ -1 +
                 SSMcustom(Z = Z, T = base_mod$T, R = base_mod$R, Q = NA,
                           state_names = c('exog.iqc', 'exog.mqc', 'level'),
                           a1 = c(1.5, 2.5, 0)),
               H = diag(NA, 2))
a
update_model <- function(pars, model) {
  # H, Q, Zを更新する
  model$Q <- array(exp(pars[1]), rep(1, 3))
  model$H <- array(diag(exp(pars[2:3]), 2), c(2, 2, 1))
  model$Z[,'level',] <- pars[4:5] 
  model$a1[1:2] <- pars[6:7] 
  model
}

fit <- fitSSM(mod_custom, inits = numeric(7), updatefn = update_model)
# fit <- fitSSM(mod_custom, inits = c(1,2,3,4,5), updatefn = update_model)
kfs <- KFS(fit$model, filtering = c('state', 'signal'), smoothing = c('state', 'signal'))
```

